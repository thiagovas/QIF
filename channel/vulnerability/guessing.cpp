#include <algorithm>
#include <vector>

#include "guessing.h"
#include "../../base/distribution.h"

namespace channel {
namespace vulnerability {

// V(X)
double Guessing::VulnerabilityPrior(const Channel& channel) const {
  base::Distribution d(channel.prior_distribution(), -1);
  return d.GuessingEntropy();
}

// V(Y)
double Guessing::VulnerabilityOut(const Channel& channel) const {
  base::Distribution d(channel.out_distribution(), -1);
  return d.GuessingEntropy();
}

// V(X|Y)
double Guessing::VulnerabilityPosterior(const Channel& channel) const {
  double guessing = 0;
  for(int i = 0; i < channel.n_out(); i++) {
    std::vector<double> dist(channel.n_in(), 0);
    for(int j = 0; j < channel.n_in(); j++)
      dist[j] = channel.j_matrix()[j][i];
    base::Distribution d(dist, -1);
    guessing += channel.out_distribution()[i] * d.GuessingEntropy();
  }
  return guessing;
}

// V(Y|X)
double Guessing::VulnerabilityReversePosterior(const Channel& channel) const {
  double guessing = 0;
  for(int i = 0; i < channel.n_in(); i++) {
    base::Distribution d(channel.j_matrix()[i], -1);
    guessing += channel.prior_distribution()[i] * d.GuessingEntropy();
  }
  return guessing;
}

// V(X|Y) = max_{y} p(y) * V(X|Y=y)  
double VulnerabilityMaxPosterior(const Channel& channel) const {
  // TBD.
  return 0;
}

// V(Y|X) = max_{x} p(x) * V(Y|X=x)
double VulnerabilityMaxReversePosterior(const Channel& channel) const {
  // TBD.
  return 0;
}

// L(X|Y) = V(X|Y) / V(X)
double LeakageMaxPosterior(const Channel& channel) const {
  // TBD.
  return 0;
}

// L(Y|X) = V(Y|X) / V(Y)
double LeakageMaxReversePosterior(const Channel& channel) const {
  // TBD.
  return 0;
}

} // namespace vulnerability
} // namespace channel
