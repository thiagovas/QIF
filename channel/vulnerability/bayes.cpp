#include <algorithm>

#include "bayes.h"


namespace channel {
namespace vulnerability {

double Bayes::VulnerabilityPrior(const Channel& channel) const {
  double vulnerability = 0;
  for(int i = 0; i < channel.n_in(); i++) {
    vulnerability = std::max(vulnerability, channel.prior_distribution()[i]);
  }
  return vulnerability;
}

double Bayes::VulnerabilityOut(const Channel& channel) const {
  double vulnerability = 0;
  for(int i = 0; i < channel.n_out(); i++) {
    vulnerability = std::max(vulnerability, channel.out_distribution()[i]);
  }
  return vulnerability;
}

double Bayes::VulnerabilityPosterior(const Channel& channel) const {
  double vulnerability = 0;
  for(int i = 0; i < channel.n_out(); i++) {
    vulnerability += channel.max_poutput()[i];
  }
  return vulnerability;
}

double Bayes::VulnerabilityReversePosterior(const Channel& channel) const {
  double vulnerability = 0;
  for(int i = 0; i < channel.n_in(); i++) {
    vulnerability += channel.max_pinput()[i];
  }
  return vulnerability;
}

// V(X|Y) = max_{y} V(X|Y=y)  
double Bayes::VulnerabilityMaxPosterior(const Channel& channel) const {
  double vulnerability = 0;
  for(auto& xv : channel.h_matrix()) {
    for(double value : xv) {
      vulnerability = std::max(vulnerability, value);
    }
  }
  return vulnerability;
}

// V(Y|X) = max_{x} V(Y|X=x)
double Bayes::VulnerabilityMaxReversePosterior(const Channel& channel) const {
  double vulnerability = 0;
  for(auto& xv : channel.c_matrix()) {
    for(double value : xv) {
      vulnerability = std::max(vulnerability, value);
    }
  }
  return vulnerability;
}

// L(X|Y) = V(X|Y) / V(X)
double Bayes::LeakageMaxPosterior(const Channel& channel) const {
  return this->VulnerabilityMaxPosterior(channel) / this->VulnerabilityPrior(channel);
}

// L(Y|X) = V(Y|X) / V(Y)
double Bayes::LeakageMaxReversePosterior(const Channel& channel) const {
  return this->VulnerabilityMaxReversePosterior(channel) / this->VulnerabilityOut(channel);
}


} // namespace vulnerability
} // namespace channel
